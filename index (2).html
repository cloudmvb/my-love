<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas Experience</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        }
        
        #canvas-container { 
            width: 100%; 
            height: 100vh; 
            display: block; 
        }
        
        #ui-layer {
            position: absolute; 
            bottom: 30px; 
            width: 100%;
            text-align: center; 
            pointer-events: none; 
            z-index: 100;
        }
        
        .badge {
            display: inline-block; 
            background: rgba(0,0,0,0.8);
            border: 2px solid #FFD700; 
            color: #FFD700;
            padding: 12px 30px; 
            border-radius: 50px;
            font-size: 18px; 
            font-weight: bold; 
            margin-bottom: 15px;
            text-transform: uppercase; 
            letter-spacing: 2px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
            text-shadow: 0 0 10px #FFD700;
            backdrop-filter: blur(10px);
        }

        .guide { 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 14px; 
            margin-bottom: 20px; 
            text-shadow: 0 2px 6px black;
            line-height: 1.6;
        }

        button {
            pointer-events: auto; 
            cursor: pointer;
            background: linear-gradient(135deg, #D32F2F 0%, #8B0000 100%); 
            color: #FFF; 
            border: 2px solid #FFD700;
            padding: 18px 60px; 
            border-radius: 35px; 
            font-weight: 800; 
            font-size: 18px;
            box-shadow: 0 0 35px rgba(255, 0, 0, 0.7), inset 0 0 20px rgba(255,255,255,0.1);
            animation: pulse 2s ease-in-out infinite;
            transition: all 0.3s ease;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.9);
        }
        
        @keyframes pulse { 
            0%, 100% { transform: scale(1); box-shadow: 0 0 35px rgba(255, 0, 0, 0.7); } 
            50% { transform: scale(1.03); box-shadow: 0 0 50px rgba(255, 0, 0, 0.9); } 
        }

        #camera-preview {
            position: absolute; 
            top: 20px; 
            right: 20px;
            width: 140px; 
            height: 105px;
            border: 3px solid rgba(255, 215, 0, 0.5); 
            transform: scaleX(-1); 
            opacity: 0.7; 
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        #error-log { 
            display: none; 
            position: absolute; 
            top: 0; 
            left: 0; 
            color: #ff6b6b; 
            background: rgba(0,0,0,0.9); 
            z-index: 999; 
            padding: 15px; 
            font-family: monospace;
            max-width: 500px;
        }
    </style>
</head>
<body>
    <div id="error-log"></div>
    
    <div id="ui-layer">
        <div id="status" class="badge">üéÑ Ch√≠p y√™u gi√°ng sinh vui v·∫ª üéÑ</div>
        <div class="guide">
            üñê <b>M·ªü tay ra:</b> Xem v√† di chuy·ªÉn &nbsp;|&nbsp; ü´∂ <b>Tr√°i tim:</b> ‚ù§Ô∏è &nbsp;|&nbsp; ‚úä <b>NƒÉm tay l·∫°i:</b> Christmas Tree  &nbsp;|&nbsp; üëå<b>Ch·ª•m 2 ng√≥n tay:</b> Xem ·∫£nh
        </div>
        <button id="btnStart" onclick="startSystem()">B·∫ÆT ƒê·∫¶U KH√ÅM PH√Å C√ÇY TH√îNG</button>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        // ==========================================
        // CONFIGURATION & RESOURCES
        // ==========================================
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; 
        bgMusic.volume = 0.8;

        const loader = new THREE.TextureLoader();
        const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg'];
        const photoTextures = [];
        photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

        // T·∫£i ·∫£nh tr√°i tim
        const heartImgTexture = loader.load('./image6.png');

        // Enhanced particle textures
        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; 
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            if (type === 'gold_glow') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 45);
                grd.addColorStop(0, '#FFFFFF'); 
                grd.addColorStop(0.15, '#FFFFE0'); 
                grd.addColorStop(0.4, '#FFD700');
                grd.addColorStop(0.7, '#FFA500');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; 
                ctx.fillRect(0, 0, 128, 128);

            } else if (type === 'red_light') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FFFFFF'); 
                grd.addColorStop(0.2, '#FFAAAA'); 
                grd.addColorStop(0.5, '#FF0000'); 
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; 
                ctx.fillRect(0, 0, 128, 128);

            } else if (type === 'green_light') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FFFFFF'); 
                grd.addColorStop(0.2, '#ccffcc'); 
                grd.addColorStop(0.5, '#00ff00'); 
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; 
                ctx.fillRect(0, 0, 128, 128);

            } else if (type === 'gift_red') {
                ctx.fillStyle = '#D32F2F'; 
                ctx.fillRect(18, 18, 92, 92);
                ctx.fillStyle = '#FFD700'; 
                ctx.fillRect(56, 18, 16, 92); 
                ctx.fillRect(18, 56, 92, 16);
                
                ctx.strokeStyle = "rgba(255,215,0,0.6)"; 
                ctx.lineWidth = 3; 
                ctx.strokeRect(18, 18, 92, 92);
                
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(64, 20, 8, 0, Math.PI * 2);
                ctx.fill();

            } else if (type === 'blue_orb') {
                const grd = ctx.createRadialGradient(50, 50, 0, 64, 64, 48);
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.3, '#66B3FF');
                grd.addColorStop(0.6, '#0066CC');
                grd.addColorStop(1, '#003366');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(64, 64, 48, 0, Math.PI * 2);
                ctx.fill();
                
                const highlight = ctx.createRadialGradient(50, 50, 0, 50, 50, 20);
                highlight.addColorStop(0, 'rgba(255,255,255,0.8)');
                highlight.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlight;
                ctx.fillRect(30, 30, 40, 40);
                
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(52, 12, 24, 8);
                ctx.fillRect(60, 8, 8, 4);

            } else if (type === 'red_orb') {
                const grd = ctx.createRadialGradient(50, 50, 0, 64, 64, 48);
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.3, '#FF6666');
                grd.addColorStop(0.6, '#CC0000');
                grd.addColorStop(1, '#660000');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(64, 64, 48, 0, Math.PI * 2);
                ctx.fill();
                
                const highlight = ctx.createRadialGradient(50, 50, 0, 50, 50, 20);
                highlight.addColorStop(0, 'rgba(255,255,255,0.8)');
                highlight.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlight;
                ctx.fillRect(30, 30, 40, 40);
                
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(52, 12, 24, 8);
                ctx.fillRect(60, 8, 8, 4);

            } else if (type === 'yellow_orb') {
                const grd = ctx.createRadialGradient(50, 50, 0, 64, 64, 48);
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.3, '#FFFF66');
                grd.addColorStop(0.6, '#FFCC00');
                grd.addColorStop(1, '#CC9900');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(64, 64, 48, 0, Math.PI * 2);
                ctx.fill();
                
                const highlight = ctx.createRadialGradient(50, 50, 0, 50, 50, 20);
                highlight.addColorStop(0, 'rgba(255,255,255,0.8)');
                highlight.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlight;
                ctx.fillRect(30, 30, 40, 40);
                
                ctx.fillStyle = '#CC6600';
                ctx.fillRect(52, 12, 24, 8);
                ctx.fillRect(60, 8, 8, 4);

            } else if (type === 'sparkle') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 35);
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.3, '#FFFFAA');
                grd.addColorStop(0.6, '#FFAA66');
                grd.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 128, 128);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            green: createCustomTexture('green_light'), 
            gift: createCustomTexture('gift_red'),
            blueOrb: createCustomTexture('blue_orb'),
            redOrb: createCustomTexture('red_orb'),
            yellowOrb: createCustomTexture('yellow_orb'),
            sparkle: createCustomTexture('sparkle')
        };

        // ==========================================
        // SYSTEM CONFIGURATION
        // ==========================================
        const CONFIG = {
            goldCount: 2000,
            redCount: 300,
            greenCount: 400, 
            giftCount: 180,
            blueOrbCount: 40,
            redOrbCount: 35,
            yellowOrbCount: 35,
            sparkleCount: 200,
            treeSparkleCount: 300,
            bgSnowCount: 600, 
            explodeRadius: 70,  
            photoOrbitRadius: 28,
            treeHeight: 75,
            treeBaseRadius: 38
        };

        let scene, camera, renderer;
        let groupGold, groupRed, groupGreen, groupGift; 
        let groupBlueOrb, groupRedOrb, groupYellowOrb;
        let groupSparkle, groupTreeSparkle, groupBgSnow; 
        let photoMeshes = [];
        let sparkleData = [];
        let treeSparkleData = [];
        let bgSnowData = []; 
        let titleMesh, starMesh, loveMesh;
        let heartPhotoMesh; 
        
        let state = 'TREE'; 
        let selectedIndex = 0;
        let handX = 0.5;

        // ==========================================
        // THREE.JS INITIALIZATION
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0f, 0.0015);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 110;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.2);
            groupRed = createParticleSystem('red', CONFIG.redCount, 3.8); 
            groupGreen = createParticleSystem('green', CONFIG.greenCount, 3.2); 
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.5); 
            groupBlueOrb = createParticleSystem('blueOrb', CONFIG.blueOrbCount, 5.0);
            groupRedOrb = createParticleSystem('redOrb', CONFIG.redOrbCount, 5.0);
            groupYellowOrb = createParticleSystem('yellowOrb', CONFIG.yellowOrbCount, 5.0); 

            createSparkleSystem();
            createTreeSparkleSystem();
            createAmbientSnow(); 
            createPhotos();
            createDecorations();
            createHeartPhoto(); 
            animate();
        }

        function createAmbientSnow() {
            const positions = [];
            bgSnowData = [];
            
            for (let i = 0; i < CONFIG.bgSnowCount; i++) {
                const x = (Math.random() - 0.5) * 400;
                const y = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 200 - 50; 
                
                positions.push(x, y, z);
                
                bgSnowData.push({
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1, 
                        -(Math.random() * 0.2 + 0.05), 
                        (Math.random() - 0.5) * 0.1
                    ),
                    originalY: y
                });
            }
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 1.5,
                color: 0xFFFFFF,
                map: textures.sparkle,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            groupBgSnow = new THREE.Points(geo, mat);
            scene.add(groupBgSnow);
        }

        function createSparkleSystem() {
            const positions = [];
            sparkleData = [];
            
            for (let i = 0; i < CONFIG.sparkleCount; i++) {
                positions.push(0, 0, 0);
                sparkleData.push({
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ),
                    life: Math.random(),
                    maxLife: 2 + Math.random() * 3,
                    photoIndex: Math.floor(Math.random() * 5)
                });
            }
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const sizes = new Float32Array(CONFIG.sparkleCount);
            for (let i = 0; i < CONFIG.sparkleCount; i++) {
                sizes[i] = 1.5 + Math.random() * 1.5;
            }
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const mat = new THREE.PointsMaterial({
                size: 2.0,
                map: textures.sparkle,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            groupSparkle = new THREE.Points(geo, mat);
            scene.add(groupSparkle);
        }

        function createTreeSparkleSystem() {
            const positions = [];
            treeSparkleData = [];
            
            for (let i = 0; i < CONFIG.treeSparkleCount; i++) {
                const h = Math.random() * CONFIG.treeHeight;
                const y = h - CONFIG.treeHeight / 2;
                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                const r = maxR * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                
                positions.push(
                    r * Math.cos(theta),
                    y,
                    r * Math.sin(theta)
                );
                
                treeSparkleData.push({
                    basePos: new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)),
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 2,
                    amplitude: 0.3 + Math.random() * 0.5
                });
            }
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const sizes = new Float32Array(CONFIG.treeSparkleCount);
            for (let i = 0; i < CONFIG.treeSparkleCount; i++) {
                sizes[i] = 1.0 + Math.random() * 2.0;
            }
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const mat = new THREE.PointsMaterial({
                size: 2.5,
                map: textures.sparkle,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            groupTreeSparkle = new THREE.Points(geo, mat);
            scene.add(groupTreeSparkle);
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [];
            const pExplodeTargets = [];
            const pTreeTargets = [];
            const pHeartTargets = [];
            const sizes = []; 
            const phases = []; 
            
            const isOrnament = (type === 'blueOrb' || type === 'redOrb' || type === 'yellowOrb');
            
            for(let i = 0; i < count; i++) {
                const h = Math.random() * CONFIG.treeHeight; 
                const y = h - CONFIG.treeHeight / 2;
                
                let radiusRatio;
                if (type === 'gold' || type === 'green') {
                    radiusRatio = Math.sqrt(Math.random());
                } else if (isOrnament) {
                    radiusRatio = 0.92 + Math.random() * 0.08;
                } else {
                    radiusRatio = 0.88 + Math.random() * 0.12;
                }
                
                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                const r = maxR * radiusRatio; 
                const theta = Math.random() * Math.PI * 2;
                pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

                const u = Math.random();
                const v = Math.random();
                const phi = Math.acos(2 * v - 1);
                const lam = 2 * Math.PI * u;
                let radMult = (type === 'gift') ? 1.25 : 1.0;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
                pExplodeTargets.push(
                    rad * Math.sin(phi) * Math.cos(lam), 
                    rad * Math.sin(phi) * Math.sin(lam), 
                    rad * Math.cos(phi)
                );

                const tHeart = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(tHeart), 3);
                let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2 * tHeart) - 2 * Math.cos(3 * tHeart) - Math.cos(4 * tHeart);
                
                const rFill = Math.pow(Math.random(), 0.35);
                hx *= rFill; 
                hy *= rFill;
                let hz = (Math.random() - 0.5) * 10 * rFill; 
                
                const noise = 1.2;
                hx += (Math.random() - 0.5) * noise;
                hy += (Math.random() - 0.5) * noise;
                hz += (Math.random() - 0.5) * noise;

                const scaleH = 2.3;
                pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz); 

                pPositions.push(pTreeTargets[i * 3], pTreeTargets[i * 3 + 1], pTreeTargets[i * 3 + 2]);
                sizes.push(size);
                phases.push(Math.random() * Math.PI * 2);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const colors = new Float32Array(count * 3);
            const baseColor = new THREE.Color();
            if (type === 'gold') baseColor.setHex(0xFFD700);
            else if (type === 'red') baseColor.setHex(0xFF0000);
            else if (type === 'green') baseColor.setHex(0x00FF00); 
            else if (type === 'blueOrb') baseColor.setHex(0x0066CC);
            else if (type === 'redOrb') baseColor.setHex(0xCC0000);
            else if (type === 'yellowOrb') baseColor.setHex(0xFFCC00);
            else baseColor.setHex(0xFFFFFF);

            for (let i = 0; i < count; i++) {
                colors[i * 3] = baseColor.r;
                colors[i * 3 + 1] = baseColor.g;
                colors[i * 3 + 2] = baseColor.b;
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            geo.userData = { 
                tree: pTreeTargets, 
                explode: pExplodeTargets, 
                heart: pHeartTargets, 
                phases: phases, 
                baseColor: baseColor, 
                baseSize: size
            };

            const mat = new THREE.PointsMaterial({
                size: size,
                map: textures[type],
                transparent: true, 
                opacity: 1.0,
                vertexColors: true, 
                blending: (type === 'gift' || isOrnament) ? THREE.NormalBlending : THREE.AdditiveBlending, 
                depthWrite: false,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(10, 10);
            const borderGeo = new THREE.PlaneGeometry(11, 11); 
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 }); 

            for (let i = 0; i < 5; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    map: photoTextures[i], 
                    side: THREE.DoubleSide 
                });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1; 
                mesh.add(border);
                mesh.visible = false; 
                mesh.scale.set(0, 0, 0);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        // --- H√ÄM T·∫†O ·∫¢NH TR√ÅI TIM ƒê√É S·ª¨A L·∫†I ---
        function createHeartPhoto() {
            const geometry = new THREE.PlaneGeometry(24, 24);
            const material = new THREE.MeshBasicMaterial({ 
                map: heartImgTexture, 
                color: 0xFFFFFF, // M√†u n·ªÅn tr·∫Øng (n·∫øu ·∫£nh ch∆∞a load)
                transparent: true, 
                side: THREE.DoubleSide,
                depthTest: false // QUAN TR·ªåNG: V·∫Ω ƒë√® l√™n m·ªçi th·ª©
            });
            heartPhotoMesh = new THREE.Mesh(geometry, material);
            heartPhotoMesh.visible = false; 
            // ƒê·∫∑t Z = 5 ƒë·ªÉ n√≥ n·∫±m TR∆Ø·ªöC c√°c h·∫°t
            heartPhotoMesh.position.set(0, 5, 5); 
            heartPhotoMesh.renderOrder = 999; // ∆Øu ti√™n v·∫Ω cao nh·∫•t
            scene.add(heartPhotoMesh);
        }

        function createDecorations() {
            const canvas = document.createElement('canvas');
            canvas.width = 1200; 
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold italic 100px "Georgia", serif';
            ctx.fillStyle = '#FFD700'; 
            ctx.textAlign = 'center';
            ctx.shadowColor = "#FF0000"; 
            ctx.shadowBlur = 50; 
            ctx.fillText("MERRY CHRISTMAS", 600, 150);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ 
                map: tex, 
                transparent: true, 
                blending: THREE.AdditiveBlending 
            });
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), mat);
            titleMesh.position.set(0, 52, 0);
            scene.add(titleMesh);

            const starCanvas = document.createElement('canvas');
            starCanvas.width = 128; 
            starCanvas.height = 128;
            const sCtx = starCanvas.getContext('2d');
            sCtx.fillStyle = "#FFFF00"; 
            sCtx.shadowColor = "#FFF"; 
            sCtx.shadowBlur = 25;
            sCtx.beginPath();
            const cx = 64, cy = 64, outer = 52, inner = 22;
            for (let i = 0; i < 5; i++) {
                sCtx.lineTo(
                    cx + Math.cos((18 + i * 72) / 180 * Math.PI) * outer, 
                    cy - Math.sin((18 + i * 72) / 180 * Math.PI) * outer
                );
                sCtx.lineTo(
                    cx + Math.cos((54 + i * 72) / 180 * Math.PI) * inner, 
                    cy - Math.sin((54 + i * 72) / 180 * Math.PI) * inner
                );
            }
            sCtx.closePath(); 
            sCtx.fill();
            
            const starTex = new THREE.CanvasTexture(starCanvas);
            const starMat = new THREE.MeshBasicMaterial({ 
                map: starTex, 
                transparent: true, 
                blending: THREE.AdditiveBlending 
            });
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), starMat);
            starMesh.position.set(0, CONFIG.treeHeight / 2 + 3, 0);
            scene.add(starMesh);

            const loveCanvas = document.createElement('canvas');
            loveCanvas.width = 1200; 
            loveCanvas.height = 300;
            const lCtx = loveCanvas.getContext('2d');
            lCtx.font = 'bold 60px "Segoe UI", sans-serif';
            lCtx.fillStyle = '#FF69B4'; 
            lCtx.textAlign = 'center';
            lCtx.shadowColor = "#FF1493"; 
            lCtx.shadowBlur = 50; 
            lCtx.fillText("B·ª§T Y√äU CH√çP NH·∫§T TH·∫æ GI·ªöI ‚ù§Ô∏è", 600, 160);
            
            const loveTex = new THREE.CanvasTexture(loveCanvas);
            const loveMat = new THREE.MeshBasicMaterial({ 
                map: loveTex, 
                transparent: true, 
                blending: THREE.AdditiveBlending 
            });
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(80, 20), loveMat);
            loveMesh.position.set(0, 0, 25);
            loveMesh.visible = false;
            scene.add(loveMesh);
        }

        function updateParticleGroup(group, type, targetState, speed, handRotY, handPosX, time) {
            const positions = group.geometry.attributes.position.array;
            const sizes = group.geometry.attributes.size.array;
            const colors = group.geometry.attributes.color.array;
            const phases = group.geometry.userData.phases;
            const baseColor = group.geometry.userData.baseColor;
            const baseSize = group.geometry.userData.baseSize;
            
            const targetKey = (targetState === 'TREE') ? 'tree' : (targetState === 'HEART' ? 'heart' : 'explode');
            const targets = group.geometry.userData[(targetState === 'PHOTO') ? 'explode' : targetKey];

            for (let i = 0; i < positions.length; i++) {
                positions[i] += (targets[i] - positions[i]) * speed;
            }
            group.geometry.attributes.position.needsUpdate = true;
            
            const count = positions.length / 3;
            const isOrnament = (type === 'blueOrb' || type === 'redOrb' || type === 'yellowOrb');
            
            if (targetState === 'TREE') {
                group.rotation.y += 0.004;
                group.position.x = 0; 
                
                for (let i = 0; i < count; i++) {
                    sizes[i] = baseSize;
                    let brightness = 1.0;
                    
                    if (type === 'red') {
                        brightness = 0.4 + 0.6 * Math.sin(time * 3.5 + phases[i]);
                    } else if (type === 'gold' || type === 'green') {
                        brightness = 0.75 + 0.45 * Math.sin(time * 8 + phases[i]);
                    } else if (isOrnament) {
                        brightness = 0.85 + 0.15 * Math.sin(time * 2 + phases[i]);
                    }
                    
                    colors[i * 3] = baseColor.r * brightness;
                    colors[i * 3 + 1] = baseColor.g * brightness;
                    colors[i * 3 + 2] = baseColor.b * brightness;
                }
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else if (targetState === 'HEART') {
                group.rotation.y = 0;
                group.position.x = 0; 
                const beatScale = 1 + Math.abs(Math.sin(time * 2.5)) * 0.18;
                group.scale.set(beatScale, beatScale, beatScale);

                for (let i = 0; i < count; i++) {
                    colors[i * 3] = baseColor.r; 
                    colors[i * 3 + 1] = baseColor.g; 
                    colors[i * 3 + 2] = baseColor.b;
                    
                    if (i % 3 === 0) sizes[i] = baseSize;
                    else sizes[i] = 0;
                }
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else {
                group.scale.set(1, 1, 1);
                group.rotation.y += (handRotY - group.rotation.y) * 0.08;
                group.position.x += (handPosX - group.position.x) * 0.08;

                for (let i = 0; i < count; i++) {
                    sizes[i] = baseSize;
                    let brightness = 1.0;
                    
                    if (type === 'gold' || type === 'red' || type === 'green') {
                        brightness = 0.7 + 0.6 * Math.sin(time * 10 + phases[i]);
                    } else if (isOrnament) {
                        brightness = 0.8 + 0.4 * Math.sin(time * 6 + phases[i]);
                    }
                    
                    colors[i * 3] = baseColor.r * brightness;
                    colors[i * 3 + 1] = baseColor.g * brightness;
                    colors[i * 3 + 2] = baseColor.b * brightness;
                }
                group.geometry.attributes.size.needsUpdate = true;
                group.geometry.attributes.color.needsUpdate = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const speed = 0.08;
            
            const handOffset = (handX - 0.5); 
            const handRotY = handOffset * 4.0; 
            const handPosX = handOffset * 70; 

            updateParticleGroup(groupGold, 'gold', state, speed, handRotY, handPosX, time);
            updateParticleGroup(groupRed, 'red', state, speed, handRotY, handPosX, time);
            updateParticleGroup(groupGreen, 'green', state, speed, handRotY, handPosX, time);
            updateParticleGroup(groupGift, 'gift', state, speed, handRotY, handPosX, time);
            updateParticleGroup(groupBlueOrb, 'blueOrb', state, speed, handRotY, handPosX, time);
            updateParticleGroup(groupRedOrb, 'redOrb', state, speed, handRotY, handPosX, time);
            updateParticleGroup(groupYellowOrb, 'yellowOrb', state, speed, handRotY, handPosX, time);

            const bgPos = groupBgSnow.geometry.attributes.position.array;
            for(let i = 0; i < bgSnowData.length; i++) {
                const data = bgSnowData[i];
                bgPos[i*3] += data.velocity.x; 
                bgPos[i*3+1] += data.velocity.y; 
                bgPos[i*3+2] += data.velocity.z; 
                
                if(bgPos[i*3+1] < -100) {
                    bgPos[i*3+1] = 100;
                    bgPos[i*3] = (Math.random() - 0.5) * 400;
                }
            }
            groupBgSnow.geometry.attributes.position.needsUpdate = true;

            photoMeshes.forEach((mesh, i) => {
                if (!mesh.material.map && photoTextures[i]) {
                    mesh.material.map = photoTextures[i]; 
                    mesh.material.needsUpdate = true;
                }
            });

            if (state === 'TREE') {
                titleMesh.visible = true; 
                starMesh.visible = true; 
                loveMesh.visible = false;
                if(heartPhotoMesh) heartPhotoMesh.visible = false; 
                
                titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                starMesh.rotation.z -= 0.025; 
                starMesh.material.opacity = 0.65 + 0.35 * Math.sin(time * 4);
                
                const baseAngle = time * 0.05; 
                const angleStep = (Math.PI * 2) / 5;
                
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = baseAngle + i * angleStep + Math.sin(time * 0.15 + i) * 0.3;
                    
                    const maxTreeHeight = CONFIG.treeHeight * 0.85;
                    const heightFactor = Math.abs(Math.sin(time * 0.08 + i * 2.1));
                    const h = heightFactor * maxTreeHeight;
                    const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                    
                    const radiusFactor = 0.3 + 0.6 * Math.sin(time * 0.1 + i * 1.7);
                    const radius = maxR * radiusFactor;
                    
                    const x = Math.sin(angle) * radius;
                    const z = Math.cos(angle) * radius;
                    
                    const y = (h - CONFIG.treeHeight / 2) + Math.sin(time * 0.2 + i * 1.3) * 1.5;
                    const maxY = CONFIG.treeHeight / 2 - 10; 
                    const finalY = Math.min(y, maxY);
                    
                    mesh.position.lerp(new THREE.Vector3(x, finalY, z), 0.03); 
                    mesh.lookAt(camera.position);
                    
                    const targetScale = 0.55 + Math.sin(time * 0.25 + i) * 0.08;
                    mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.03);
                });

                const sparklePositions = groupSparkle.geometry.attributes.position.array;
                for (let i = 0; i < sparkleData.length; i++) {
                    const data = sparkleData[i];
                    data.life += 0.016;
                    
                    if (data.life >= data.maxLife) {
                        data.life = 0;
                        const photoIndex = data.photoIndex;
                        const photo = photoMeshes[photoIndex];
                        sparklePositions[i * 3] = photo.position.x;
                        sparklePositions[i * 3 + 1] = photo.position.y;
                        sparklePositions[i * 3 + 2] = photo.position.z;
                        data.velocity.set(
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                    } else {
                        sparklePositions[i * 3] += data.velocity.x;
                        sparklePositions[i * 3 + 1] += data.velocity.y;
                        sparklePositions[i * 3 + 2] += data.velocity.z;
                        data.velocity.multiplyScalar(0.98);
                    }
                }
                groupSparkle.geometry.attributes.position.needsUpdate = true;
                groupSparkle.visible = true;

                const treeSparklePositions = groupTreeSparkle.geometry.attributes.position.array;
                const treeSparkleSizes = groupTreeSparkle.geometry.attributes.size.array;
                for (let i = 0; i < treeSparkleData.length; i++) {
                    const data = treeSparkleData[i];
                    const offset = Math.sin(time * data.speed + data.phase) * data.amplitude;
                    treeSparklePositions[i * 3] = data.basePos.x + offset * 0.5;
                    treeSparklePositions[i * 3 + 1] = data.basePos.y + offset;
                    treeSparklePositions[i * 3 + 2] = data.basePos.z + offset * 0.3;
                    const pulse = 0.5 + 0.5 * Math.sin(time * data.speed * 2 + data.phase);
                    treeSparkleSizes[i] = (1.0 + Math.random() * 2.0) * (0.5 + pulse * 0.5);
                }
                groupTreeSparkle.geometry.attributes.position.needsUpdate = true;
                groupTreeSparkle.geometry.attributes.size.needsUpdate = true;
                groupTreeSparkle.visible = true;
                groupTreeSparkle.rotation.y += 0.003;

            } else if (state === 'HEART') {
                titleMesh.visible = false; 
                starMesh.visible = false; 
                loveMesh.visible = true;
                photoMeshes.forEach(m => { m.visible = false; });
                groupSparkle.visible = false;
                groupTreeSparkle.visible = false;
                
                const s = 1 + Math.abs(Math.sin(time * 2.5)) * 0.12;
                loveMesh.scale.set(s, s, 1);
                
                if (heartPhotoMesh) {
                    heartPhotoMesh.visible = true;
                    heartPhotoMesh.scale.set(s, s, 1);
                }

            } else if (state === 'EXPLODE') {
                titleMesh.visible = false; 
                starMesh.visible = false; 
                loveMesh.visible = false;
                groupSparkle.visible = false;
                groupTreeSparkle.visible = false;
                if(heartPhotoMesh) heartPhotoMesh.visible = false; 
                
                const baseAngle = groupGold.rotation.y; 
                const angleStep = (Math.PI * 2) / 5;
                let bestIdx = 0; 
                let maxZ = -999;
                
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = baseAngle + i * angleStep;
                    const centerX = handPosX; 
                    const x = centerX + Math.sin(angle) * CONFIG.photoOrbitRadius;
                    const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
                    const y = Math.sin(time * 0.8 + i) * 3.5; 
                    mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
                    mesh.lookAt(camera.position);
                    if (z > maxZ) { 
                        maxZ = z; 
                        bestIdx = i; 
                    }
                    if (z > 5) { 
                        const ds = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.9; 
                        mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0.5, 0.5, 0.5), 0.1);
                    }
                });
                selectedIndex = bestIdx;

            } else if (state === 'PHOTO') {
                loveMesh.visible = false;
                groupSparkle.visible = false;
                groupTreeSparkle.visible = false;
                if(heartPhotoMesh) heartPhotoMesh.visible = false; 
                
                photoMeshes.forEach((mesh, i) => {
                    if (i === selectedIndex) {
                        mesh.position.lerp(new THREE.Vector3(0, 0, 65), 0.12);
                        mesh.scale.lerp(new THREE.Vector3(4.0, 4.0, 4.0), 0.12);
                        mesh.lookAt(camera.position); 
                        mesh.rotation.z = 0;
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                    }
                });
            }
            
            renderer.render(scene, camera);
        }

        // ==========================================
        // HAND TRACKING & CONTROL
        // ==========================================
        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play().catch(e => console.log('Audio autoplay prevented:', e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');
            const statusDiv = document.getElementById('status');
            
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            hands.setOptions({ 
                maxNumHands: 2, 
                modelComplexity: 1, 
                minDetectionConfidence: 0.5, 
                minTrackingConfidence: 0.5 
            });

            hands.onResults(results => {
                ctx.clearRect(0, 0, 140, 105); 
                ctx.drawImage(results.image, 0, 0, 140, 105);

                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0]; 
                    const h2 = results.multiHandLandmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    
                    if (distIndex < 0.15 && distThumb < 0.15) {
                        state = 'HEART'; 
                        statusDiv.innerText = "ü´∂ ‚ù§Ô∏è"; 
                        statusDiv.style.borderColor = "#FF69B4";
                        statusDiv.style.color = "#FF69B4";
                        statusDiv.style.boxShadow = "0 0 25px rgba(255, 105, 180, 0.8)";
                        return;
                    }
                }

                if (results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x; 
                    
                    const tips = [8, 12, 16, 20]; 
                    const wrist = lm[0];
                    let openDist = 0; 
                    tips.forEach(i => openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
                    const avgDist = openDist / 4;
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                    if (avgDist < 0.25) { 
                        state = 'TREE'; 
                        statusDiv.innerText = "‚úä Christmas Tree"; 
                        statusDiv.style.borderColor = "#FFD700";
                        statusDiv.style.color = "#FFD700";
                        statusDiv.style.boxShadow = "0 0 25px rgba(255, 215, 0, 0.6)";
                    } else if (pinchDist < 0.06) {
                        state = 'PHOTO'; 
                        statusDiv.innerText = "üëå Xem ·∫£nh"; 
                        statusDiv.style.borderColor = "#00FFFF";
                        statusDiv.style.color = "#00FFFF";
                        statusDiv.style.boxShadow = "0 0 25px rgba(0, 255, 255, 0.6)";
                    } else {
                        state = 'EXPLODE'; 
                        statusDiv.innerText = "üñê Kh√°m Ph√°"; 
                        statusDiv.style.borderColor = "#FFA500";
                        statusDiv.style.color = "#FFA500";
                        statusDiv.style.boxShadow = "0 0 25px rgba(255, 165, 0, 0.6)";
                    }
                } else {
                    state = 'TREE'; 
                    statusDiv.innerText = "üéÑ Ch√≠p y√™u gi√°ng sinh vui v·∫ª üéÑ"; 
                    statusDiv.style.borderColor = "#FFD700";
                    statusDiv.style.color = "#FFD700";
                    statusDiv.style.boxShadow = "0 0 25px rgba(255, 215, 0, 0.6)";
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { 
                    await hands.send({ image: video }); 
                }, 
                width: 320, 
                height: 240
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            if (camera) { 
                camera.aspect = window.innerWidth / window.innerHeight; 
                camera.updateProjectionMatrix(); 
                renderer.setSize(window.innerWidth, window.innerHeight); 
            }
        });
        
        function logError(e) { 
            const errorLog = document.getElementById('error-log');
            errorLog.style.display = 'block'; 
            errorLog.innerText += e + "\n"; 
        }
    </script>
</body>
</html>